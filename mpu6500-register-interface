#include <Wire.h>

#define ICM_ADDR   0x68
#define WHO_AM_I   0x75
#define PWR_MGMT_1 0x6B
#define ACCEL_CONFIG 0x1C 
#define GYRO_CONFIG 0x1B 
#define ACCEL_SENSITIVITY 4096.0f     // LSB/g for +/- 8g range
#define GYRO_SENSITIVITY 16.4f        // LSB/(°/s) for +/- 2000 dps range

uint8_t ACCEL_RANGE = 0x10;
uint8_t GYRO_RANGE = 0x18;

int16_t accl_x, accl_y, accl_z; // variables for accelerometer raw data
int16_t gyro_x, gyro_y, gyro_z; // variables for gyro raw data
int16_t temperature; // variable for temp data

void setup() {
  Serial.begin(4800);
  Wire.begin();

//accelerometer config
  Wire.beginTransmission(ICM_ADDR);
  Wire.write(ACCEL_CONFIG);
  Wire.write(ACCEL_RANGE); //range set to +/-8g
  Wire.endTransmission();

//gyro config
  Wire.beginTransmission(ICM_ADDR);
  Wire.write(GYRO_CONFIG);
  Wire.write(GYRO_RANGE); //range set to +/- 2000°/s
  Wire.endTransmission();

  Wire.beginTransmission(ICM_ADDR);
  Wire.write(WHO_AM_I); //we are just pointing at the internal register, basically giving the internal addr to the device [IMU] to help us; we do not talk to internal registers.. just giving maibox addresses to the device to give us data from that particular addr
  Wire.endTransmission(false); //false stop means "i'm done giving orders, but don't hang up yet"; (repeated start condition) basically it keeps the communication line open/reserved for the current master.
  Wire.requestFrom(ICM_ADDR, 1, true); //requestFrom(addr, quantity, stop); quantity = #BYTES; 1 byte can store a number between 0-255 and since the register output for WHO_AM_I falls in that range, we use 1 byte of data;

  byte id = Wire.read(); 
  Serial.print("ID: 0x");
  Serial.println(id, HEX);

  if (id == 0x70) {
    Wire.beginTransmission(ICM_ADDR);
    Wire.write(PWR_MGMT_1); /*power 1 = mcb for a house and contrls the on/off for the whole chip, whereas power 2 is like individual room switches that can turn on/off individual components on the chip (like accelerometer, gyro, etc)*/
    Wire.write(0x00); // Wake up
    Wire.endTransmission();
    Serial.println("IMU Awake.");
  } else {
    Serial.println("Connection Failed.");
  }
}

void loop() {
Wire.beginTransmission(ICM_ADDR);
Wire.write(0x3B); // ACCEL_XOUT_H {starting register}
Wire.endTransmission(false); //restart condition so that the connection is alive
Wire.requestFrom(ICM_ADDR, 7*2, true); //requesting 7*2 = 14 registers

//"Wire.read()<<8 | Wire.read;" left bitwise operation, two registers are stored in the same variable
accl_x = Wire.read()<<8 | Wire.read();   // reading registers: 0x3B (ACCEL_XOUT_H) and 0x3C (ACCEL_XOUT_L)
accl_y = Wire.read()<<8 | Wire.read();   // reading registers: 0x3D (ACCEL_YOUT_H) and 0x3E (ACCEL_YOUT_L)
accl_z = Wire.read()<<8 | Wire.read();   // reading registers: 0x3F (ACCEL_ZOUT_H) and 0x40 (ACCEL_ZOUT_L)
temperature = Wire.read()<<8 | Wire.read();   // reading registers: 0x41 (TEMP_OUT_H) and 0x42 (TEMP_OUT_L)
gyro_x = Wire.read()<<8 | Wire.read();   // reading registers: 0x43 (GYRO_XOUT_H) and 0x44 (GYRO_XOUT_L)
gyro_y = Wire.read()<<8 | Wire.read();   // reading registers: 0x45 (GYRO_YOUT_H) and 0x46 (GYRO_YOUT_L)
gyro_z = Wire.read()<<8 | Wire.read();   // reading registers: 0x47 (GYRO_ZOUT_H) and 0x48 (GYRO_ZOUT_L)

//print out data on serial monitor
Serial.print("aX = "); Serial.print((float)accl_x / ACCEL_SENSITIVITY); Serial.print("g");
Serial.print(" | aY = "); Serial.print((float)accl_y / ACCEL_SENSITIVITY); Serial.print("g");
Serial.print(" | aZ = "); Serial.print((float)accl_z / ACCEL_SENSITIVITY); Serial.print("g");
Serial.print(" | tmp = "); Serial.print((float)temperature/333.87 + 21.00); Serial.print("°C");
Serial.print(" | gX = "); Serial.print((float)gyro_x / GYRO_SENSITIVITY); Serial.print("°");
Serial.print(" | gY = "); Serial.print((float)gyro_y / GYRO_SENSITIVITY); Serial.print("°");
Serial.print(" | gZ = "); Serial.print((float)gyro_z / GYRO_SENSITIVITY); Serial.print("°");
Serial.println();


}
